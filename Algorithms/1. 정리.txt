유클리드 호제법.
	최대공약수(Great Common Measure)
		f(a, b) = gcd(a, b) 에서 a % b == 0 이라면 gcd(a, b) = b
		만약 a % b != 0 이라면 f(a, b) = f(b, a % b);
		
		while (true) {
			R = X % Y;
			if (R == 0) break;
			else {
				X = Y;
				Y = R;
			}
		}
		return Y;

	최소공배수(Least Common Multiple)
		X * Y / GCM = xG * yG / G
================================================================
강한 골드바흐의 추측
	4 이상의 모든 짝수는 두 소수의 합으로 표현할 수 있다.
약한 골드바흐의 추측
	5 보다 큰 모든 홀수는 세 소수의 합으로 나타낼 수 있다.
	홀수 = 짝수 + 홀수로만 표현 가능하므로, value - 2가 소수인지 판단하면 된다.
================================================================
DP - 행렬 곱셈.
	A_1(0, 1), A_2(1, 2), A_3(2, 3), ..., A_n(n - 1, n) 의 행렬 곱셈에서 가장 적게 곱하는 방법.
	DP[i][j] = A_i 에서 A_j까지 곱할 때의 최소 곱셈 수.
	중간에 행렬 A_k가 끼어드므로,
	for k: i ~ j
	DP[i][j] = MIN_FUNC(DP[i][k] + DP[k + 1][j] + d[i - 1] * d[k] * d[j]

	ps) d[i - 1] * d[k] * d[j]: A_1 * A_2 후 A_3을 곱하면, (0, 2) 와 (2, 3)을 곱하므로...

		
		
		========= 백준 풀이 ========== 1019번 - 책 페이지
		A = 10 / B = 39인 경우
		10, 11, 12, 13, 14, 15, 16, 17, 18, 19
		20, 21, 22, 23, 24, 25, 26, 27, 28, 29
		30, 31, 32, 33, 34, 35, 36, 37, 38, 39
		=> A ~ B 1의 자리 수는 0 ~ 9까지 각각 (3 - 1 + 1)개

		A = 1345 / B = 8742
		1. A를 1350으로 만들면서 각 자리수 계산 / B를 8739로 만들면서 각 자리수 계산
		2. 그리고 873 - 135 + 1 만큼 각 자리수 증가
		3. A = 135 / B = 873 으로 변경.
		4. A 값 135가 136로 바뀔 때, 1과 3과 5가 10씩 증가.
		   B 값 873가 872로 바뀔 때, 8과 7과 3이 10씩 증가
		5. A = 140 / B = 869 사이 각 숫자마다 (86 - 14 + 1) * 10만큼 증가.
		
================================================================
* 가중치가 없는 최단 경로는 무조건 BFS입니다.
	DFS는 특정 칸에 처음 도달했을 때까지의 경로의 길이가
	다른 경로를 통해 도달한 길이보다 짧다는 보장이 전혀 없다.

* 14500: 정사각형 4개를 이어 붙인 1 * 1의 정사각형 집단 => DFS로 표현이 가능하다는 생각!

* 다익스트라 알고리즘은 해당 점까지 도달하는 최저 비용을 도출하는 알고리즘이다.
  따라서 그 점에 도달하는 모든 비용이 계산되어 나온다는 점!!! 이를 이용한 문제
	=> 1854, 5719

================================================================


================================================================
우선 첫번째 난관은 외벽이 원형이라는 점이다.
0번 지점을 거쳐가는 경로가 존재할 수 있기 때문에 단순한 1차원 배열로 외벽을 표현하기엔 부족하다.
이때 사용할 수 있는 기법이 배열의 길이를 2배 늘려주는 것이다.
	=> n=12 이고 weak = [1, 5, 6, 10] 일 때 weak = [1, 5, 6, 10, 13, 17, 18, 22] 로 표현한다.

예시: https://mjmjmj98.tistory.com/38
================================================================
조합 = A물건 5개, B물건 3개, C물건 8개를 모두 조합하는 경우는?
	=> (5 + 1) * (3 + 1) * (8 + 1)..... 0개인 경우를 제외한다면 1을 뺀다.

================================================================
// 특정값 중 제일 작은 위치
int find_starting(vector<string> words, int len, int from, int to)
{
    while (from <= to)
    {
        int mid = (from + to) / 2;
        if (len <= words[mid].length())
            to = mid - 1;
        else
            from = mid + 1;
    }
    return from;
}

================================================================
int solution(int n, vector<int> weak, vector<int> dist) {
    int answer = 2e9;
    int weak_size = weak.size();
    
    weak.resize(weak_size * 2);
    for (int i = weak_size; i < weak_size * 2; i++)
        weak[i] = n + weak[i - weak_size];
    
    sort(dist.begin(), dist.end());
    
    do {
        for (int i = 0; i < weak_size; i++) {
            int start = weak[i];
            int finish = weak[i + weak_size - 1];
            for (int j = 0; j < dist.size(); j++) {
                start += dist[j];
                if (start >= finish) {
                    answer = min(answer, j + 1);
                    break;
                }
                int next = upper_bound(weak.begin(), weak.end(), start) - weak.begin();
                start = weak[next];
            }
        }
    }while (next_permutation(dist.begin(), dist.end()));
    
    if (answer == 2e9)
        return -1;
    
    return answer;
}

================================================================