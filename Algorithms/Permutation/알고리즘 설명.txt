	next_permutation 원리

1. v[idx - 1] < v[idx]를 만족하는 가장 큰 idx를 찾습니다.
                                 -----------------------------------------------
	int idx = N - 1;
	while (idx > 0 && V[idx - 1] >= V[idx])
		idx--;
	if (idx == 0)
		마지막 순열
--------------------------------------------------------------------------------

2. v[idx2] > v[idx-1]을 만족하는 가장 큰 idx2를 찾습니다.
                                 -----------------------------------------------
	int idx2 = N - 1;
	while (V[idx - 1] >= V[idx2])
		idx2--;
--------------------------------------------------------------------------------

3. v[idx - 1]과 v[idx2]를 뒤바꿔줍니다.
                                 -----------------------------------------------
	swap(V[idx - 1], V[idx2]);
--------------------------------------------------------------------------------

4. idx부터 순열을 뒤집어줍니다.
                                 -----------------------------------------------
	idx2 = N - 1;
	while (idx < idx2) {
		swap(V[idx], V[idx2);
		idx++;
		idx2--;
	}
--------------------------------------------------------------------------------

	prev_permutation 원리

1. v[idx - 1] > v[idx]를 만족하는 가장 큰 idx를 찾습니다.

2. idx2 >= idx이면서 v[idx2] < v[idx-1]을 만족하는 가장 큰 idx2를 찾습니다.

3. v[idx - 1]과 v[idx2]를 뒤바꿔줍니다.

4. idx부터 순열을 뒤집어줍니다.